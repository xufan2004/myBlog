(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{345:function(n,a,e){"use strict";e.r(a);var t=e(13),r=Object(t.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"数据类型的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型的使用"}},[n._v("#")]),n._v(" 数据类型的使用")]),n._v(" "),a("h2",{attrs:{id:"显式类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显式类型"}},[n._v("#")]),n._v(" 显式类型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//number\nlet a:number // a被设置成了number类型，往后赋值只能为数字\na = 1 // 正确赋值\na = "1" || true || ..... // TS编译器会报错\n\n//string\nlet a:string //a被设置成了string类型，往后赋值只能为字符串\na = "hello" // 正确赋值\na = 1 || true || ..... // TS编译器会报错\n\n//boolean\nlet a:boolean //a被设置成了boolean类型，往后赋值只能为布尔值\na = true || false // 正确赋值\na = 1 || "1" || ..... // TS编译器会报错\n\n//字面量\nlet a:1 //a被设置成了字面量1，往后a赋值只能为1\na = 1 // 正确赋值\na = ..... // 任何值TS编译器都会报错\n\n// 也可以这样写定义多个\nlet a:number | string\n此时a的可以被设置成字符串或数字\n\n// any\nlet a:any\na = 1 || true || "1" || ....\n// 设置any可以赋值任意类型的值，相当于关闭了TS的类型校验\n\n// unknown\nlet a:unknown // 设置unknown可以赋值任意类型的值，类似于any\n\n// unknown与any的区别\nlet a:any\nlet b:unknown\nlet c:string\n\nc = a // any可以给任意类型赋值，但是会影响被赋值变量的类型 let c:string 变成了 c:any\n\nc = b // TS编译器会报错，不能直接赋值给string类型\n\n// 需要这样赋值(类型校验) OR 类型断言\n\nif(typeof b === \'string\' ){\n    \x3c!-- 类型校验 --\x3e\n    c = b // TS编译器不会报错，正常赋值\n}\n\nc = b as string // 类型断言 可以用来告诉解析器变量的实际类型 类似于 c = <string>b\n注意：不可 c = b<string>\n\n// void\nfunction fn():void{\n    return 1 || ......  //  编译器报错\n    return undefined // ok\n    return // ok\n}\n\n// never\nfunction fn():never{\n    return ......  //  编译器报错 不能有任何返回值 不常用\n}\n\n// object\nlet a:object //有点鸡肋 很少使用常用来限制对象里的值，而不是限制类型\n\nlet b:{ name:string } // 对象里的值名为name且值必须是字符串\nb = {\n    name:"333"\n}\n\nlet d:{ name:string, [proName:string]:any}\n// 表示对象中除name外可以有任意类型的键值\n\nlet e:{ name:string, age?:number } // 表示对象中必须有一个name属性且值为string，age可填可不填\n\n// array\n\n// 类型[] || Array<类型>\n\nlet a:string[] // a被设置成了数组类型，且往后赋值只能为string\n\nlet a:number[] // 意义同上\n\nlet a:Array<number> // 同 a:number 一样数组中只能包含数字\n\n// tuple(固定长度的数组)\n[类型,类型]\n\nlet a:[string,number] // a的类型为数组，且a中的内容第一个只能是string，第二个是number\n且不存在第三个\n\n// enum(枚举)\n\nenum a {\n    b = 0,\n    c = "你好"\n}\n\n用法 let d = a.b || a.c\n\n// 函数的使用\n\nlet a:(a:number,b:number) => number\n//定义一个方法 参数都为number ，返回值也会number\n\na = function(a,b){\n    return 值 // number\n}\n\nfunction sum(a:number,b:number){\n    return a+b\n}\n\nsum(123,456) // return 579\nsum(123,"456") // TS编译器会报错\n\n// 定义方法的返回值类型为number\nfunction sum(a,b):number{\n    return a+b\n}\n\nsum("hello","word") // return "helloword" TS编译器会报错\n\n')])])]),a("h2",{attrs:{id:"隐式类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隐式类型"}},[n._v("#")]),n._v(" 隐式类型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('let a;\n// TS编译器会把a的类型设置为any let a:any\n\nlet a = 1\n// TS编译器会把a的类型设置为number let a:number\n\nlet a = "1"\n// TS编译器会把a的类型设置为string let a:string\n\nlet a = true || false\n// TS编译器会把a的类型设置为boolean let a:boolean\n')])])]),a("h2",{attrs:{id:"类型的别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型的别名"}},[n._v("#")]),n._v(" 类型的别名")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let a: 1 | 2 | 3 | 5\nlet b: 1 | 2 | 3 | 5\n\n// 上发过于麻烦且不清晰，定义一个类型别名\n// 语法\n\ntype 别名 = 类型\n\ntype numList = 1 | 2 | 3 | 5\n\nlet a:numList == let a: 1 | 2 | 3 | 5\n\n\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);